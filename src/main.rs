use env_logger::{Builder, Env};
use log::{debug, error};
use prometheus_exporter::prometheus::register_gauge;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, net::SocketAddr, panic};

#[derive(Debug, Deserialize)]
pub struct GoEControllerApiResponse {
    #[serde(rename = "ccn")]
    pub category_names: Vec<String>,
    #[serde(rename = "ccp")]
    pub category_powers: Vec<Option<f32>>,
}

#[derive(Debug, Deserialize, PartialEq, Eq, Hash)]
pub enum GoEControllerCategory {
    #[serde(rename = "Home")]
    Home,
    #[serde(rename = "Grid")]
    Grid,
    #[serde(rename = "Car")]
    Car,
    #[serde(rename = "Relais")]
    Relais,
    #[serde(rename = "Solar")]
    Solar,
    #[serde(rename = "Akku")]
    Akku,
    #[serde(rename = "Custom1")]
    Custom1,
    #[serde(rename = "Custom2")]
    Custom2,
    #[serde(rename = "Custom3")]
    Custom3,
    #[serde(rename = "Custom4")]
    Custom4,
    #[serde(rename = "Custom5")]
    Custom5,
    #[serde(rename = "Custom6")]
    Custom6,
    #[serde(rename = "Custom7")]
    Custom7,
    #[serde(rename = "Custom8")]
    Custom8,
    #[serde(rename = "Custom9")]
    Custom9,
    #[serde(rename = "Custom10")]
    Custom10,
}

#[derive(Debug, Serialize)]
pub enum ExporterError {
    CategoryUnknown,
}

impl TryFrom<&str> for GoEControllerCategory {
    type Error = ExporterError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "Home" => Ok(Self::Home),
            "Grid" => Ok(Self::Grid),
            "Car" => Ok(Self::Car),
            "Relais" => Ok(Self::Relais),
            "Solar" => Ok(Self::Solar),
            "Akku" => Ok(Self::Akku),
            "Custom 1" => Ok(Self::Custom1),
            "Custom 2" => Ok(Self::Custom2),
            "Custom 3" => Ok(Self::Custom3),
            "Custom 4" => Ok(Self::Custom4),
            "Custom 5" => Ok(Self::Custom5),
            "Custom 6" => Ok(Self::Custom6),
            "Custom 7" => Ok(Self::Custom7),
            "Custom 8" => Ok(Self::Custom8),
            "Custom 9" => Ok(Self::Custom9),
            "Custom 10" => Ok(Self::Custom10),
            _ => Err(Self::Error::CategoryUnknown),
        }
    }
}

impl Into<HashMap<GoEControllerCategory, Option<f32>>> for GoEControllerApiResponse {
    fn into(self) -> HashMap<GoEControllerCategory, Option<f32>> {
        let mut map = HashMap::new();

        for i in 0..self.category_names.len() {
            map.insert(
                GoEControllerCategory::try_from(self.category_names[i].as_str())
                    .expect(format!("Category unknown: {}", self.category_names[i]).as_str()),
                self.category_powers[i],
            );
        }

        map
    }
}

fn main() {
    // Setup logger with default level info so we can see the messages from
    // prometheus_exporter.
    Builder::from_env(Env::default().default_filter_or("info")).init();

    // Parse address used to bind exporter to.
    let addr_raw = "0.0.0.0:9186";
    let addr: SocketAddr = addr_raw.parse().expect("can not parse listen addr");

    // Start exporter and update metrics every five seconds.
    let exporter = prometheus_exporter::start(addr).expect("can not start exporter");
    let fetch_interval = std::time::Duration::from_secs(30);

    let home_gauge = register_gauge!("home_power_usage", "shows the whole home power usage")
        .expect("couldn't create home gauge");
    let grid_gauge = register_gauge!("grid_power_usage", "shows the power taken from the grid")
        .expect("couldn't create grid gauge");
    let car_gauge = register_gauge!(
        "car_power_usage",
        "shows the power used by the car charging"
    )
    .expect("couldn't create car gauge");
    let solar_gauge = register_gauge!("solar_power_gauge", "shows the power generated by solar")
        .expect("couldn't create solar gauge");

    let controller_ip = match std::env::var("GOE_CONTROLLER_IP") {
        Ok(ip) => ip,
        Err(_err) => {
            error!(target: "init", "env var GOE_CONTROLLER_IP must be set!");
            panic!("env var GOE_CONTROLLER_IP must be set!");
        }
    };

    loop {
        {
            let goe_query_response =
                do_go_e_query(/*ip address of go-e controller*/ &controller_ip);
            debug!("parsed_response: {:?}", goe_query_response);

            let map_results: HashMap<_, _> = goe_query_response.into();

            home_gauge.set(
                map_results
                    .get(&GoEControllerCategory::Home)
                    .unwrap_or(&Some(0 as f32))
                    .unwrap_or(0 as f32) as f64,
            );
            grid_gauge.set(
                map_results
                    .get(&GoEControllerCategory::Grid)
                    .unwrap_or(&Some(0 as f32))
                    .unwrap_or(0 as f32) as f64,
            );
            car_gauge.set(
                map_results
                    .get(&GoEControllerCategory::Car)
                    .unwrap_or(&Some(0 as f32))
                    .unwrap_or(0 as f32) as f64,
            );
            solar_gauge.set(
                map_results
                    .get(&GoEControllerCategory::Solar)
                    .unwrap_or(&Some(0 as f32))
                    .unwrap_or(0 as f32) as f64,
            );

            // Will block until duration is elapsed.
            let _guard = exporter.wait_duration(fetch_interval);
        }
    }
}

fn do_go_e_query(ip_address: &String) -> GoEControllerApiResponse {
    let goe_response = reqwest::blocking::get(format!("http://{}/api/status", ip_address))
        .expect("can not get metrics from exporter")
        .text()
        .expect("can not body text from request");

    let goe_parsed: GoEControllerApiResponse = {
        match serde_json::from_str(&goe_response.as_str()) {
            Ok(v) => v,
            Err(error) => {
                error!(target: "response deserialization", "Couldn't deserialize!");
                error!(target: "response deserialization", "Error: {:?}", error);
                error!(target: "response deserialization", "Response: {:?}", goe_response);
                panic!("Couldn't deserialize");
            }
        }
    };

    goe_parsed
}
